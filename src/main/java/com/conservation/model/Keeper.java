package com.conservation.model;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Abstract base class for all keeper types in the conservation system.
 * 
 * A keeper is responsible for managing one to four cages and the animals within them.
 * Two concrete implementations exist:
 * - HeadKeeper: Senior staff with full management responsibilities
 * - AssistantKeeper: Junior staff with basic care responsibilities
 * 
 * Business rule: Each keeper must be assigned to 1-4 cages (no more, no less when active)
 */
public abstract class Keeper {
    
    /**
     * Position enum for keeper roles in the organisation.
     */
    public enum Position {
        HEAD_KEEPER,
        ASSISTANT_KEEPER
    }
    
    protected int keeperId;
    protected String firstName;
    protected String surname;
    protected String address;
    protected String contactNumber;
    protected Position position;
    protected List<Integer> allocatedCageIds;
    
    /**
     * Default constructor for creating empty Keeper instance.
     * Required for XML deserialisation.
     */
    public Keeper() {
        this.allocatedCageIds = new ArrayList<>();
    }
    
    /**
     * Full constructor for creating a Keeper with all attributes.
     * 
     * @param keeperId unique identifier (auto-generated by system)
     * @param firstName keeper's first name
     * @param surname keeper's surname
     * @param address keeper's residential address
     * @param contactNumber keeper's phone number
     * @param position keeper's role (HEAD_KEEPER or ASSISTANT_KEEPER)
     * @throws IllegalArgumentException if any required field is null or invalid
     */
    public Keeper(int keeperId, String firstName, String surname, 
                  String address, String contactNumber, Position position) {
        validateFields(firstName, surname, address, contactNumber, position);
        
        this.keeperId = keeperId;
        this.firstName = firstName;
        this.surname = surname;
        this.address = address;
        this.contactNumber = contactNumber;
        this.position = position;
        this.allocatedCageIds = new ArrayList<>();
    }
    
    /**
     * Validates all required fields are present and valid.
     * 
     * @throws IllegalArgumentException if validation fails
     */
    private void validateFields(String firstName, String surname, String address,
                                String contactNumber, Position position) {
        if (firstName == null || firstName.trim().isEmpty()) {
            throw new IllegalArgumentException("Keeper first name cannot be null or empty");
        }
        if (surname == null || surname.trim().isEmpty()) {
            throw new IllegalArgumentException("Keeper surname cannot be null or empty");
        }
        if (address == null || address.trim().isEmpty()) {
            throw new IllegalArgumentException("Keeper address cannot be null or empty");
        }
        if (contactNumber == null || contactNumber.trim().isEmpty()) {
            throw new IllegalArgumentException("Keeper contact number cannot be null or empty");
        }
        if (position == null) {
            throw new IllegalArgumentException("Keeper position cannot be null");
        }
    }
    
    /**
     * Allocates a cage to this keeper.
     * 
     * Business rule: Keeper can have maximum 4 cages allocated.
     * 
     * @param cageId the cage ID to allocate
     * @throws IllegalStateException if keeper already has 4 cages
     * @throws IllegalArgumentException if cage is already allocated to this keeper
     */
    public void allocateCage(int cageId) {
        if (allocatedCageIds.size() >= 4) {
            throw new IllegalStateException("Keeper cannot have more than 4 cages");
        }
        if (allocatedCageIds.contains(cageId)) {
            throw new IllegalArgumentException("Cage " + cageId + " is already allocated to this keeper");
        }
        allocatedCageIds.add(cageId);
    }
    
    /**
     * Removes a cage allocation from this keeper.
     * 
     * @param cageId the cage ID to remove
     * @return true if cage was removed, false if cage was not allocated to this keeper
     */
    public boolean removeCage(int cageId) {
        return allocatedCageIds.remove(Integer.valueOf(cageId));
    }
    
    /**
     * Gets the number of cages currently allocated to this keeper.
     * 
     * @return count of allocated cages (0 to 4)
     */
    public int getAllocatedCageCount() {
        return allocatedCageIds.size();
    }
    
    /**
     * Checks if this keeper can accept more cage allocations.
     * 
     * @return true if keeper has less than 4 cages, false otherwise
     */
    public boolean canAcceptMoreCages() {
        return allocatedCageIds.size() < 4;
    }
    
    /**
     * Gets the full name of the keeper.
     * 
     * @return full name in format "FirstName Surname"
     */
    public String getFullName() {
        return firstName + " " + surname;
    }
    
    /**
     * Abstract method to get keeper-specific responsibilities description.
     * 
     * Implemented differently by HeadKeeper and AssistantKeeper.
     * 
     * @return description of responsibilities
     */
    public abstract String getResponsibilities();
    
    /**
     * Abstract method to check if keeper can perform specific management tasks.
     * 
     * @return true if keeper has management permissions, false otherwise
     */
    public abstract boolean hasManagementPermissions();
    
    // Getters and Setters
    
    public int getKeeperId() {
        return keeperId;
    }
    
    public void setKeeperId(int keeperId) {
        this.keeperId = keeperId;
    }
    
    public String getFirstName() {
        return firstName;
    }
    
    public void setFirstName(String firstName) {
        if (firstName == null || firstName.trim().isEmpty()) {
            throw new IllegalArgumentException("Keeper first name cannot be null or empty");
        }
        this.firstName = firstName;
    }
    
    public String getSurname() {
        return surname;
    }
    
    public void setSurname(String surname) {
        if (surname == null || surname.trim().isEmpty()) {
            throw new IllegalArgumentException("Keeper surname cannot be null or empty");
        }
        this.surname = surname;
    }
    
    public String getAddress() {
        return address;
    }
    
    public void setAddress(String address) {
        if (address == null || address.trim().isEmpty()) {
            throw new IllegalArgumentException("Keeper address cannot be null or empty");
        }
        this.address = address;
    }
    
    public String getContactNumber() {
        return contactNumber;
    }
    
    public void setContactNumber(String contactNumber) {
        if (contactNumber == null || contactNumber.trim().isEmpty()) {
            throw new IllegalArgumentException("Keeper contact number cannot be null or empty");
        }
        this.contactNumber = contactNumber;
    }
    
    public Position getPosition() {
        return position;
    }
    
    public void setPosition(Position position) {
        if (position == null) {
            throw new IllegalArgumentException("Keeper position cannot be null");
        }
        this.position = position;
    }
    
    public List<Integer> getAllocatedCageIds() {
        // Return defensive copy
        return new ArrayList<>(allocatedCageIds);
    }
    
    public void setAllocatedCageIds(List<Integer> allocatedCageIds) {
        this.allocatedCageIds = new ArrayList<>(allocatedCageIds);
    }
    
    /**
     * Checks equality based on keeper ID.
     * 
     * @param obj the object to compare
     * @return true if objects are equal, false otherwise
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Keeper keeper = (Keeper) obj;
        return keeperId == keeper.keeperId;
    }
    
    /**
     * Generates hash code based on keeper ID.
     * 
     * @return hash code for this keeper
     */
    @Override
    public int hashCode() {
        return Objects.hash(keeperId);
    }
    
    /**
     * Returns string representation of the keeper.
     * 
     * @return string representation
     */
    @Override
    public String toString() {
        return String.format("Keeper{id=%d, name='%s', position=%s, cages=%d}",
                keeperId, getFullName(), position, allocatedCageIds.size());
    }
}
